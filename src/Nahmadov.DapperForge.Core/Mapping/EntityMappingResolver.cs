using System.ComponentModel.DataAnnotations.Schema;
using System.Reflection;

namespace Nahmadov.DapperForge.Core.Mapping;

/// <summary>
/// Resolves the final immutable <see cref="EntityMapping"/> from a metadata snapshot and fluent configuration.
/// </summary>
internal static class EntityMappingResolver
{
    public static EntityMapping Resolve(EntityMetadataSnapshot snapshot, EntityConfig config, string? defaultSchema)
    {
        ArgumentNullException.ThrowIfNull(snapshot);
        ArgumentNullException.ThrowIfNull(config);

        var type = snapshot.EntityType;
        var tableName = !string.IsNullOrWhiteSpace(config.TableName)
            ? config.TableName!
            : snapshot.TableName ?? type.Name;

        var schema = !string.IsNullOrWhiteSpace(config.Schema)
            ? config.Schema
            : snapshot.Schema ?? defaultSchema;

        var props = snapshot.ScalarProperties;
        if (props.Count == 0)
            throw new InvalidOperationException($"Type {type.Name} has no writable public properties.");

        var keyProps = ResolveKeyProperties(config, snapshot, props);
        var propertyMappings = BuildPropertyMappings(config, snapshot, keyProps);
        var foreignKeys = BuildForeignKeyMappings(snapshot, propertyMappings);

        var isReadOnly = config.IsReadOnly || snapshot.IsReadOnly;

        return new EntityMapping(
            type,
            tableName,
            schema,
            keyProps,
            props,
            propertyMappings,
            isReadOnly,
            foreignKeys);
    }

    private static List<PropertyInfo> ResolveKeyProperties(
        EntityConfig config,
        EntityMetadataSnapshot snapshot,
        IReadOnlyList<PropertyInfo> props)
    {
        if (!config.HasKey)
            return [];

        if (config.KeyProperties.Count > 0)
        {
            return config.KeyProperties.Select(keyName =>
                    props.FirstOrDefault(p => string.Equals(p.Name, keyName, StringComparison.Ordinal))
                    ?? throw new InvalidOperationException(
                        $"Key property '{keyName}' not found on entity type '{snapshot.EntityType.Name}'."))
                .ToList();
        }

        if (snapshot.KeyAttributeProperties.Count > 0)
            return snapshot.KeyAttributeProperties.ToList();

        var convention = props.FirstOrDefault(p => string.Equals(p.Name, "Id", StringComparison.OrdinalIgnoreCase))
            ?? props.FirstOrDefault(p => string.Equals(p.Name, snapshot.EntityType.Name + "Id", StringComparison.OrdinalIgnoreCase))
            ?? props.FirstOrDefault(p => NormalizeKeyName(p.Name) == NormalizeKeyName(snapshot.EntityType.Name + "Id"));

        if (convention is not null)
            return [convention];

        if (!config.IsReadOnly && !snapshot.IsReadOnly)
        {
            throw new InvalidOperationException(
                $"Type {snapshot.EntityType.Name} has no key property. Define HasKey(...) or mark the entity as read-only/HasNoKey.");
        }

        return [];
    }

    private static List<PropertyMapping> BuildPropertyMappings(
        EntityConfig config,
        EntityMetadataSnapshot snapshot,
        IReadOnlyCollection<PropertyInfo> keyProps)
    {
        var mappings = new List<PropertyMapping>(snapshot.ScalarProperties.Count);
        var keyLookup = keyProps.ToHashSet();

        foreach (var prop in snapshot.ScalarProperties)
        {
            config.Properties.TryGetValue(prop.Name, out var propConfig);
            snapshot.PropertyAttributes.TryGetValue(prop, out var attrSnapshot);

            var explicitColumn = string.IsNullOrWhiteSpace(propConfig?.ColumnName) ? null : propConfig!.ColumnName;
            var columnName = explicitColumn
                ?? attrSnapshot?.ColumnName
                ?? prop.Name;

            var generatedOption = attrSnapshot?.GeneratedOption;
            var isKey = keyLookup.Contains(prop);

            if (propConfig?.IsAutoGenerated is bool autoGeneratedOverride)
            {
                generatedOption = autoGeneratedOverride
                    ? generatedOption ?? DatabaseGeneratedOption.Identity
                    : null;
            }
            else if (config.HasKey &&
                     isKey &&
                     keyLookup.Count == 1 &&
                     generatedOption is null &&
                     string.IsNullOrWhiteSpace(propConfig?.SequenceName))
            {
                generatedOption = DatabaseGeneratedOption.Identity;
            }

            var isRequired = propConfig?.IsRequired ?? ((attrSnapshot?.HasRequiredAttribute ?? false) || isKey);
            var maxLength = propConfig?.MaxLength ?? attrSnapshot?.MaxLength;
            var isReadOnly = propConfig?.IsReadOnly ?? false;
            var sequenceName = propConfig?.SequenceName;

            mappings.Add(new PropertyMapping(
                prop,
                columnName,
                generatedOption,
                isReadOnly,
                isRequired,
                maxLength,
                sequenceName));
        }

        return mappings;
    }

    private static IReadOnlyList<ForeignKeyMapping> BuildForeignKeyMappings(
        EntityMetadataSnapshot snapshot,
        IReadOnlyCollection<PropertyMapping> propertyMappings)
    {
        if (snapshot.ForeignKeyAttributes.Count == 0)
            return Array.Empty<ForeignKeyMapping>();

        var foreignKeys = new List<ForeignKeyMapping>();

        foreach (var (fkProp, fkAttr) in snapshot.ForeignKeyAttributes)
        {
            // Find navigation property
            var navProp = snapshot.AllProperties.FirstOrDefault(p =>
                string.Equals(p.Name, fkAttr.NavigationPropertyName, StringComparison.Ordinal))
                ?? throw new InvalidOperationException(
                    $"Navigation property '{fkAttr.NavigationPropertyName}' not found on entity '{snapshot.EntityType.Name}'.");

            var fkColumnMapping = propertyMappings.FirstOrDefault(pm => pm.Property == fkProp)
                ?? throw new InvalidOperationException($"Property '{fkProp.Name}' has no column mapping.");

            var fkColumnName = fkColumnMapping.ColumnName;
            var principalKeyPropName = fkAttr.PrincipalKeyPropertyName ?? "Id";
            var principalType = fkAttr.PrincipalEntityType;
            var principalTableAttr = principalType.GetCustomAttribute<TableAttribute>();
            var principalTableName = principalTableAttr?.Name ?? principalType.Name;
            var principalSchema = principalTableAttr?.Schema;

            var principalKeyProp = principalType.GetProperties(BindingFlags.Instance | BindingFlags.Public)
                .FirstOrDefault(p => string.Equals(p.Name, principalKeyPropName, StringComparison.Ordinal))
                ?? throw new InvalidOperationException(
                    $"Key property '{principalKeyPropName}' not found on entity '{principalType.Name}'.");

            var principalColumnAttr = principalKeyProp.GetCustomAttribute<ColumnAttribute>();
            var principalColumnName = principalColumnAttr?.Name ?? principalKeyPropName;

            foreignKeys.Add(new ForeignKeyMapping(
                navProp,
                fkProp,
                principalType,
                fkColumnName,
                principalColumnName,
                principalTableName,
                principalSchema));
        }

        return foreignKeys;
    }

    private static string NormalizeKeyName(string name)
        => new(name.Where(char.IsLetterOrDigit).Select(char.ToUpperInvariant).ToArray());
}
